- ## HTTP 缓存

1. 首先通过 Cache-Control 验证强缓存是否可用，如果强缓存可用，那么直接读取缓存。
2. 如果不可以，那么进入协商缓存阶段，发起 HTTP 请求，服务器通过请求头中是否带上 if-Modified-Since 和 If-None-Match 这些条件请求字段检查资源是否更新：若资源更新，那么返回资源和 200 状态码；如果资源未更新，那么告诉浏览器直接使用缓存获取资源。

- ## 常用状态码
  ● 101 切换请求协议，从 HTTP 切换到 WebSocket  
  ● 200 请求成功，有响应体  
  ● 301 永久重定向：会缓存  
  ● 302 临时重定向：不会缓存  
  ● 304 协商缓存命中  
  ● 403 服务器禁止访问  
  ● 404 资源未找到  
  ● 400 请求错误  
  ● 500 服务器端错误  
  ● 503 服务器繁忙  
  302 表示临时重定向，这个资源只是暂时不能被访问了，但是之后过一段时间还是可以继续访问，一般是访问某个网站的资源需要权限时，会需要用户去登录，跳转到登录页面之后登录之后，还可以继续访问。  
  301 类似，都会跳转到一个新的网站，但是 301 代表访问的地址的资源被永久移除了，以后都不应该访问这个地址，搜索引擎抓取的时候也会用新的地址替换这个老的。可以在返回的响应的 location 首部去获取到返回的地址。301 的场景如下：

● 比如从 http://baidu.com，跳转到 https://baidu.com  
● 域名换了

- ## 计算机网络系列

1. **7 层架构**：应用层（HTTP）、表示层、会话层、传输层（TCP/IP）、网络层（IP）、数据链路层、物理层
2. **HTTTPS 是什么**：HTTPS 是在 HTTP 和 TCP 之间建立了一个安全层，HTTP 与 TCP 通信的时候，必须先进过一个安全层，对数据包进行加密，然后将加密后的数据包传送给 TCP，相应的 TCP 必须将数据包解密，才能传给上面的 HTTP。  
   浏览器传输一个 client_random 和加密方法列表，服务器收到后，传给浏览器一个 server_random、加密方法列表和数字证书（包含了公钥），然后浏览器对数字证书进行合法验证，如果验证通过，则生成一个 pre_random，然后用公钥加密传给服务器，服务器用 client_random、server_random 和 pre_random ，使用公钥加密生成 secret，然后之后的传输使用这个 secret 作为秘钥来进行数据的加解密。
3. **三次握手和四次挥手**：  
   `三次握手主要流程`：（少一次都无法确认客户端的接收能力。）  
   ● 一开始双方处于 CLOSED 状态，然后服务端开始监听某个端口进入 LISTEN 状态  
   ● 然后客户端主动发起连接，发送 SYN，然后自己变为 SYN-SENT，seq = x  
   ● 服务端收到之后，返回 SYN seq = y 和 ACK ack = x + 1（对于客户端发来的 SYN），自己变成 SYN-REVD  
   ● 之后客户端再次发送 ACK seq = x + 1, ack = y + 1 给服务端，自己变成 EASTABLISHED 状态，服务端收到 ACK，也进入 ESTABLISHED  
   `四次挥手主要流程`：  
   ● 一开始都处于 ESTABLISH 状态，然后客户端发送 FIN 报文，带上 seq = p，状态变为 FIN-WAIT-1  
   ● 服务端收到之后，发送 ACK 确认，ack = p + 1，然后进入 CLOSE-WAIT 状态  
   ● 客户端收到之后进入 FIN-WAIT-2 状态  
   ● 过了一会等数据处理完，再次发送 FIN、ACK，seq = q，ack = p + 1，进入 LAST-ACK 阶段  
   ● 客户端收到 FIN 之后，客户端收到之后进入 TIME_WAIT（等待 2MSL），然后发送 ACK 给服务端 ack = 1 + 1  
   ● 服务端收到之后进入 CLOSED 状态

- ## 长连接、短连接、长轮询、短轮询

1. 是不是只要设置 Connection 为 keep-alive 就算是长连接了？  
   当然是的，但要服务器和客户端都设置。

2. 我们平时用的是不是长连接？  
   这个也毫无疑问，当然是的。（现在用的基本上都是 HTTP1.1 协议，你观察一下就会发现，基本上 Connection 都是 keep-alive。而且 HTTP 协议文档上也提到了，HTTP1.1 默认是长连接，也就是默认 Connection 的值就是 keep-alive）

3. 我们这种普通的 Web 应用（比如博客园，我的个人博客这种）用长连接有啥好处？需不需要关掉长连接而使用短连接？  
   首先，刚才已经说了，长连接是为了复用，这个在之前 LZ 就明白。那既然长连接是指的 TCP 连接，也就是说复用的是 TCP 连接。那这就很好解释了，也就是说，长连接情况下，多个 HTTP 请求可以复用同一个 TCP 连接，这就节省了很多 TCP 连接建立和断开的消耗。  
   比如你请求了博客园的一个网页，这个网页里肯定还包含了 CSS、JS 等等一系列资源，如果你是短连接（也就是每次都要重新建立 TCP 连接）的话，那你每打开一个网页，基本要建立几个甚至几十个 TCP 连接，这浪费了多少资源就不用 LZ 去说了吧。  
   但如果是长连接的话，那么这么多次 HTTP 请求（这些请求包括请求网页内容，CSS 文件，JS 文件，图片等等），其实使用的都是一个 TCP 连接，很显然是可以节省很多消耗的。  
   这样一解释，就很明白了，不知道大家看了这些解释感觉如何，反正 LZ 在自己想明白以后，有种豁然开朗的感觉。

4. WebSocket 是长轮询。  
   具体比如在一个电商场景，商品的库存可能会变化，所以需要及时反映给用户，所以客户端会不停的发请求，然后服务器端会不停的去查变化，不管变不变，都返回，这个是短轮询。  
   而长轮询则表现为如果没有变，就不返回，而是等待变或者超时（一般是十几秒）才返回，如果没有返回，客户端也不需要一直发请求，所以减少了双方的压力。
